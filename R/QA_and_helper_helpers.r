
#' Checks overlap in new_node_coordinates() generated by merged_node_coords_helper()
#'
#' @importFrom dagitty exposures outcomes coordinates latents
#' @return dagitty objecty with coordinates.
#' @noRd
quality_check_merged_node_coords_helper <- function(new_node_name_vec_x,
                                                    new_node_name_vec_y,
                                                    num_nodes_x,
                                                    num_nodes_y,
                                                    new_x_coords,
                                                    new_y_coords,
                                                    existing_coordinates_x,
                                                    existing_coordinates_y,
                                                    threshold){

  num_vars_x <- length(existing_coordinates_x)
  num_vars_y <- length(existing_coordinates_y)


  ## internal check against other generated coords ##

  # x-coords
  if( num_nodes_x > 0 ){

    coords_df <- data.table::as.data.table(

      sapply(1:num_nodes_x, function(a){
        sapply(1:num_nodes_x, function(b){

          sqrt( diff( range( c(new_x_coords[a],
                               new_x_coords[b]) ) ) )**2

        })
      }) + diag(nrow = num_nodes_x, ncol = num_nodes_x) )


    coords_df$ID <- 1:num_nodes_x
    coords_df <- coords_df[apply(coords_df >= threshold, 1, all)]

    keep_coord_names_x <- new_node_name_vec_x[ coords_df$ID ]

  }

  # y-coords
  if( num_nodes_y > 0 ){

    coords_df <-  data.table::as.data.table(

      sapply(1:num_nodes_y, function(a){
        sapply(1:num_nodes_y, function(b){
          sqrt( diff( range( c(new_y_coords[a],
                               new_y_coords[b]) ) ) )**2

        })
      }) + diag(nrow = num_nodes_y, ncol = num_nodes_y) )

    coords_df$ID <- 1:num_nodes_y
    coords_df <- coords_df[apply(coords_df >= threshold, 1, all)]

    keep_coord_names_y <- new_node_name_vec_y[ coords_df$ID ]

  }


  ## check against existing coordinates ##
  if( length(existing_coordinates_x) > 0 ){

    if( num_nodes_x > 0 ){

      coords_df <- data.table::as.data.table(

        sapply(1:num_vars_x, function(a){
          sapply(1:num_nodes_x, function(b){
            sqrt( diff( range( c(existing_coordinates_x[a],
                                 new_x_coords[b]) ) ) )**2

          })
        }) )

      if( num_nodes_x == 1 ){

        new_x_coords <- new_x_coords[ sum(coords_df) / length( existing_coordinates_x ) >= threshold ]

      }else{

        coords_df$ID <- 1:num_nodes_x
        coords_df <- coords_df[apply(coords_df >= threshold, 1, all)]

        new_x_coords <- new_x_coords[ coords_df$ID ]

        new_x_coords <- new_x_coords[ names(new_x_coords) %in% keep_coord_names_x]

      }

    }

  }


  if( length(existing_coordinates_y) > 0 ){

    if( num_nodes_y > 0 ){

      coords_df <- data.table::as.data.table(

        sapply(1:num_vars_y, function(a){
          sapply(1:num_nodes_y, function(b){
            sqrt( diff( range( c(existing_coordinates_y[a],
                                 new_y_coords[b]) ) ) )**2

          })
        }) )

      if( num_nodes_y == 1 ){

        new_y_coords <- new_y_coords[ sum(coords_df) / length( existing_coordinates_y ) >= threshold ]

      }else{

        coords_df$ID <- 1:num_nodes_y
        coords_df <- coords_df[apply(coords_df >= threshold, 1, all)]

        new_y_coords <- new_y_coords[ coords_df$ID ]

        new_y_coords <- new_y_coords[ names(new_y_coords) %in% keep_coord_names_y]

      }

    }

  }


  new_coordinates <- list( x = c(existing_coordinates_x, new_x_coords),  y = c(existing_coordinates_y, new_y_coords) )

  return(new_coordinates)

}


#' Checks node coordinates are not overlapping
#'
#' @importFrom dagitty exposures outcomes coordinates latents
#' @param dag dagitty object
#' @param latent_variables vector of latent variable nodes.
#' @param existing_coordinates vector of latent variable nodes.
#' @return dagitty objecty with coordinates.
#' @noRd
quality_check_new_coordinates_helper <- function(dag, grouped_nodes, num_nodes, new_coordinates, existing_coords, threshold = 1){
  #existing_coords <- coordinates # used for debugging new_node_coordinates()
  #grouped_nodes <- new_node_names # used for debugging new_node_coordinates()
  #grouped_nodes <- latent_variables # used for debugging generate_latent_coordinates()
  #num_nodes <- num_latents # used for debugging generate_latent_coordinates()

  num_vars <- length(names(dag))

  unlisted_coords_x <- new_coordinates$x
  unlisted_coords_y <- new_coordinates$y

  ## internal check against other generated latent coords ##

  if( num_nodes > 1 ){

    coords_x_sum_diff_within_new_nodes <- sum( sapply(1:num_nodes, function(a){

      diff_list <- sapply(1:num_nodes, function(b){

        sqrt( diff( range( c(unlisted_coords_x[a], unlisted_coords_x[b]) ) ) )**2

      })

    }), na.rm=TRUE) / num_nodes

    check_x_coords_within_new_nodes <- coords_x_sum_diff_within_new_nodes > threshold


    coords_y_sum_diff_within_new_nodes <- sum( sapply(1:num_nodes, function(a){

      diff_list <- sapply(1:num_nodes, function(b){

        sqrt( diff( range( c(unlisted_coords_y[a], unlisted_coords_y[b]) ) ) )**2

      })

    }), na.rm=TRUE) / num_nodes

    check_y_coords_within_new_nodes <- coords_y_sum_diff_within_new_nodes > threshold

    if( check_x_coords_within_new_nodes == FALSE | check_y_coords_within_new_nodes == FALSE ){

      return(FALSE)

    }

  }

  #existing_coords <- coordinates

  ## external check against existing coords ##
  existing_coords_x <- existing_coords$x
  existing_coords_y <- existing_coords$y

  # remove group node names from existing coords vectors
  existing_coords_x <- existing_coords_x[ !names(existing_coords_x) %in% grouped_nodes]
  existing_coords_y <- existing_coords_y[ !names(existing_coords_y) %in% grouped_nodes]

  if( num_nodes > 1 ){

    coords_x_min_diff_to_existing_nodes <- min(

      sapply(1:num_nodes, function(a){

        diff_list <- sapply(1:num_vars, function(b){

          sqrt( diff( range( c(unlisted_coords_x[a], existing_coords_x[b]) ) ) )**2

        })
      })

      , na.rm=TRUE )

    check_new_x_coords_to_existing <- coords_x_min_diff_to_existing_nodes > threshold


    coords_y_min_diff_to_existing_nodes <- min(

      sapply(1:num_nodes, function(a){

        diff_list <- sapply(1:num_vars, function(b){

          sqrt( diff( range( c(unlisted_coords_y[a], existing_coords_y[b]) ) ) )**2

        })
      })

      , na.rm=TRUE )

    check_new_y_coords_to_existing <- coords_y_min_diff_to_existing_nodes > threshold


  }else{


    coords_x_min_diff_to_existing_nodes <- mean(

      sapply(1:num_nodes, function(a){

        diff_list <- sapply(1:num_vars, function(b){

          sqrt( diff( range( c(unlisted_coords_x[a], existing_coords_x[b]) ) ) )**2

        })
      })

      , na.rm=TRUE )

    check_new_x_coords_to_existing <- coords_x_min_diff_to_existing_nodes > threshold


    coords_y_min_diff_to_existing_nodes <- mean(

      sapply(1:num_nodes, function(a){

        diff_list <- sapply(1:num_vars, function(b){

          sqrt( diff( range( c(unlisted_coords_y[a], existing_coords_y[b]) ) ) )**2

        })
      })

      , na.rm=TRUE )

    check_new_y_coords_to_existing <- coords_y_min_diff_to_existing_nodes > threshold


  }

  if( check_new_x_coords_to_existing == FALSE | check_new_y_coords_to_existing == FALSE ){

    return(FALSE)

  }


  # if the difference between new nodes and all other nodes is greater than one
  return(TRUE)

}


#' Add nodes to a dagitty object
#'
#' create_names_copy_nodes_helper() is a second helper function for copy_nodes() through copy_nodes_helper()
#'
#' It uses existing nodes to create new node names for specified repeats/time points.
#'
#' @importFrom data.table as.data.table
#' @param existing_nodes Vector of existing node names, used as a reference for the new graph nodes, e.g., c("Z1", "Z2", "Z3").
#' @param new_node_type A suffix added to each of the new node names, e.g. "post_treatment", or "t" (a number is added for each repeat if num_repeats is specified)
#' @param num_repeats Number of additional copies of nodes, such as time points. Each repeat number is included at the end of new node names (new_new_t1, new_node_t2, etc.).
#' @returns A vector of new node names.
#' @noRd
create_names_copy_nodes_helper <- function(existing_nodes, new_node_type, num_repeats){
  .datatable.aware <- TRUE

  seq_repeats <- seq(num_repeats)

  new_node_names <- NULL

  if( length( existing_nodes ) > 0 ){

    if( length( seq_repeats ) == 1 ){

      new_node_names <- paste0(existing_nodes, "_", new_node_type)


    }else{

      new_node_names <- sapply(1:length(seq_repeats), function(x){

        new_node_names <- paste0(existing_nodes, "_", new_node_type, seq_repeats[x])

      })

    }

  }

  return(new_node_names)


}



#' Connect new nodes to their reference nodes
#'
#' connect_new_and_existing_nodes() is a helper function for draw_edges_for_copy_nodes_helper() and add_nodes().
#'
#' @importFrom data.table as.data.table
#' @param new_node_names Inputted vector of node names to be added to the graph.
#' @param existing_node_names Inputted vector of node names, used as a reference for the new graph nodes.
#' @returns A data frame of edges connecting new nodes to their reference nodes, and each subsequent time point to the next.
#' @noRd
connect_new_and_existing_nodes <- function(new_node_names, existing_node_names){
  .datatable.aware <- TRUE

  new_node_names_vec <- as.character(unlist(new_node_names, use.names = FALSE))

  num_ref_nodes <- length(existing_node_names)

  new_nodes_list <- suppressWarnings( lapply(1:num_ref_nodes, function(x){

    new_nodes_list <- list( v = existing_node_names[x], e = "->", w = new_node_names_vec[x] )

  }) )

  new_nodes_df <- data.table::as.data.table( do.call( rbind, new_nodes_list ) )

  num_new_nodes <- length(new_node_names_vec)

  if( num_new_nodes > num_ref_nodes & length(new_node_names) > 1 ){

    new_nodes_list <- suppressWarnings( lapply(1:( nrow(new_node_names) - 1 ), function(x){

      new_nodes_list <- lapply( 1:nrow(new_node_names), function(y){

        new_nodes_list <- list( v = new_node_names[y, x], e = "->", w = new_node_names[y, (x+1)] )

      })

    }) )

    if( !all( is.null(unlist(new_nodes_list)) ) ){

      new_nodes_list <-  data.table::as.data.table( do.call( rbind, unlist(new_nodes_list, recursive = FALSE) ) )
    }

    new_nodes_df <- rbind(new_nodes_df, new_nodes_list)

  }else if( length(new_node_names) > 1 ){

    new_nodes_list <- suppressWarnings( lapply( 1:( nrow(new_node_names) - 1 ), function(y){

      new_nodes_list <- list( v = new_node_names[y,], e = "->", w = new_node_names[y + 1,] )

    })
    )

    if( !all( is.null(unlist(new_nodes_list)) ) ){

      new_nodes_list <-  data.table::as.data.table( do.call( rbind, new_nodes_list) )

      new_nodes_list[] <- lapply(new_nodes_list, as.character)
    }

    new_nodes_df <- rbind(new_nodes_df, new_nodes_list)

  }

  return(new_nodes_df)

}


#' Connect new nodes to parents
#'
#' connect_new_nodes_to_parent_new_nodes() is a helper function for draw_edges_for_copy_nodes_helper() and add_nodes().
#'
#' @importFrom data.table as.data.table
#' @param new_node_names Inputted vector of node names to be added to the graph.
#' @param new_node_parents_in_existing_nodes Inputted vector of new node parent names in the supplied reference nodes.
#' @returns A list of edges connecting new nodes to their parent nodes, at time point.
#' @noRd
connect_new_nodes_to_parent_new_nodes <- function(new_node_names, existing_node_names, new_node_parents_in_existing_nodes){ # needs checking single new_node_name input
  .datatable.aware <- TRUE
  # check if more than one reference node
  if( length(existing_node_names) > 1 ){

    # connect new node to parent nodes (also included in reference nodes)
    new_nodes_list <- suppressWarnings(

      lapply(1:( length(new_node_names) ), function(t){ # t = each time point

        new_nodes_list <- lapply( 1:nrow(new_node_names), function(y){ # y = each reference (new) node e.g. Z1_a, Z2_a, Z3_a

          if( length( unlist(new_node_parents_in_existing_nodes[[y]]) ) > 0){

            new_nodes_list <- lapply( 1:length( unlist(new_node_parents_in_existing_nodes[[y]]) ), function(x){ # x = each parent node

              if( length( unlist(new_node_parents_in_existing_nodes[[y]][[x]]) ) > 0 ){

                if( length( unlist(new_node_parents_in_existing_nodes[[y]][[x]]) ) > 1){

                  new_nodes_list <- list( v =  new_node_parents_in_existing_nodes[[y]][[x,t]], e = "->", w = new_node_names[y, t] )

                }else{

                  new_nodes_list <- list( v =  new_node_parents_in_existing_nodes[[y]][[x]], e = "->", w = new_node_names[y, t] )

                }
              }

            })

          }
        })

      })
    )


    new_nodes_list <- do.call( rbind, new_nodes_list )

    if( !all( is.null(unlist(new_nodes_list)) ) ){

      new_nodes_list <-  data.table::as.data.table( do.call( rbind, unlist(new_nodes_list, recursive = FALSE) ) )
    }

    new_nodes_list[] <- lapply(new_nodes_list, as.character)


  }else{

    new_nodes_list <- suppressWarnings(

      lapply(1:( nrow(new_node_names) ), function(t){ # t = each time point

        if( length( unlist(new_node_parents_in_existing_nodes) ) > 0 ){

          new_nodes_list <- lapply( 1:length( unlist(new_node_parents_in_existing_nodes[[t]]) ), function(x){ # x = each parent node

            if( length( unlist(new_node_parents_in_existing_nodes[[t]][[x]]) ) > 0 ){

              new_nodes_list <- list( v =  new_node_parents_in_existing_nodes[[t]][[x]], e = "->", w = new_node_names[t,] )

            }

          } )

        }

      } )
    )

    if( !all( is.null(unlist(new_nodes_list)) ) ){

      new_nodes_list <-  data.table::as.data.table( do.call( rbind, new_nodes_list) )

      new_nodes_list[] <- lapply(new_nodes_list, as.character)
    }

  }

  return(new_nodes_list)
}


#' Connect new nodes to parents
#'
#' connect_post_treatment_node_parents() is a helper function for draw_edges_for_copy_nodes_helper() and add_nodes().
#'
#' @importFrom data.table as.data.table
#' @param new_node_names Inputted vector of node names to be added to the graph.
#' @param new_node_parents Inputted vector of new node parent names.
#' @returns A list of edges connecting new nodes to their parent nodes, at time point.
#' @noRd
connect_post_treatment_node_parents <- function(new_node_names, existing_node_names, new_node_parents){
  .datatable.aware <- TRUE
  if( length(existing_node_names) > 1 ){
    # new nodes parents
    new_nodes_list <- suppressWarnings(

      lapply(1:( length(new_node_names) ), function(t){ # t = each time point

        new_nodes_list <- lapply( 1:nrow(new_node_names), function(y){ # y = each reference (new) node e.g. Z1_a, Z2_a, Z3_a

          if( length( unlist(new_node_parents[[y]]) ) > 0){

            new_nodes_list <- lapply( 1:length( unlist(new_node_parents[[y]]) ), function(x){ # x = each parent node


              if( length( unlist(new_node_parents[[y]][[x]]) ) > 0 ){

                new_nodes_list <- list( v =  new_node_parents[[y]][[x]], e = "->", w = new_node_names[y, t] )

              }else{

                new_nodes_list <- list( v =  new_node_parents[[y]], e = "->", w = new_node_names[y, t] )


              }


            })

          }


        })

      }) )

    new_nodes_list <- do.call( rbind, new_nodes_list )

    if( !all( is.null(unlist(new_nodes_list)) ) ){

      new_nodes_list <-  data.table::as.data.table( do.call( rbind, unlist(new_nodes_list, recursive = FALSE) ) )
    }

    new_nodes_list[] <- lapply(new_nodes_list, as.character)

  }else{

    # new nodes parents
    new_nodes_list <- suppressWarnings(

      lapply(1:( nrow(new_node_names) ), function(t){ # t = each time point

        if( length( unlist(new_node_parents) ) > 0 ){

          new_nodes_list <- lapply( 1:length( new_node_parents ), function(y){ # x = each parent node

            if( length( unlist(new_node_parents[[y]]) ) > 0 ){

              new_nodes_list <- lapply( 1:length( unlist(new_node_parents[[y]]) ), function(x){ # x = each parent node

                if( length( unlist(new_node_parents[[y]][[x]]) ) > 0 ){

                  new_nodes_list <- list( v =  new_node_parents[[y]][[x]], e = "->", w = new_node_names[t,] )

                }else{

                  new_nodes_list <- list( v =  new_node_parents[[y]], e = "->", w = new_node_names[t,] )


                }

              })


            }

          })

        }

      }) )

    new_nodes_list <- do.call( rbind, new_nodes_list )

    #if( !all( is.null( unlist(new_nodes_list) ) ) & length( unlist(new_node_parents) ) > 1 ){
    #  new_nodes_list <-  as.data.table( do.call( rbind, new_nodes_list) )
    #  new_nodes_list[] <- lapply(new_nodes_list, as.character)
    #}else

    if( !all( is.null(unlist(new_nodes_list) ) ) ){

      new_nodes_list <-  data.table::as.data.table( do.call( rbind, unlist(new_nodes_list, recursive = FALSE) ) )

      new_nodes_list[] <- lapply(new_nodes_list, as.character)


    }


  }

  return(new_nodes_list)
}


#' Connect new nodes to children
#'
#' connect_post_treatment_node_children() is a helper function for draw_edges_for_copy_nodes_helper() and add_nodes().
#'
#' @importFrom data.table as.data.table
#' @param new_node_names Inputted vector of node names to be added to the graph.
#' @param new_node_children Inputted vector of new nodes' children.
#' @returns A list of edges connecting new nodes to their child nodes, at time point.
#' @noRd
connect_post_treatment_node_children <- function(new_node_names, existing_node_names, new_node_children){
  .datatable.aware <- TRUE

  if( length(existing_node_names) > 1 ){

    # new nodes children
    new_nodes_list <- suppressWarnings(

      lapply(1:( length(new_node_names) ), function(t){ # t = each time point

        new_nodes_list <- lapply( 1:nrow(new_node_names), function(y){ # y = each reference (new) node e.g. Z1_a, Z2_a, Z3_a

          if( length( unlist(new_node_children[[y]]) ) > 0){

            new_nodes_list <- lapply( 1:length( unlist(new_node_children[[y]]) ), function(x){ # x = each children node


              if( length( unlist(new_node_children[[y]][[x]]) ) > 0 ){

                new_nodes_list <- list( v = new_node_names[y, t], e = "->", w = new_node_children[[y]][[x]] )

              }else{

                new_nodes_list <- list( v =  new_node_names[y, t], e = "->", w =  new_node_children[[y]])


              }

            })

          }


        })

      }) )

    new_nodes_list <- do.call( rbind, new_nodes_list )

    if( !all( is.null(unlist(new_nodes_list)) ) ){

      new_nodes_list <-  data.table::as.data.table( do.call( rbind, unlist(new_nodes_list, recursive = FALSE) ) )
    }

    new_nodes_list[] <- lapply(new_nodes_list, as.character)

  }else{

    # new nodes children
    new_nodes_list <- suppressWarnings(

      lapply(1:( nrow(new_node_names) ), function(t){ # t = each time point

        if( length( unlist(new_node_children) ) > 0 ){

          new_nodes_list <- lapply( 1:length( new_node_children ), function(y){ # y = each child node

            if( length( unlist(new_node_children[[y]]) ) > 0 ){

              new_nodes_list <- lapply( 1:length( unlist(new_node_children[[y]]) ), function(x){ # x = each child node

                if( length( unlist(new_node_children[[y]][[x]]) ) > 0 ){

                  new_nodes_list <- list( v = new_node_names[t,], e = "->", w = new_node_children[[y]][[x]])

                }else{

                  new_nodes_list <- list( v = new_node_names[t,], e = "->", w = new_node_children[[y]])


                }

              })


            }

          })

        }

      }) )

    new_nodes_list <- do.call( rbind, new_nodes_list )

    #if( !all( is.null( unlist(new_nodes_list) ) ) & length( unlist(new_node_children) ) > 1 ){
    #  new_nodes_list <-  as.data.table( unlist( do.call( rbind, new_nodes_list), recursive = FALSE ) )
    #  new_nodes_list[] <- lapply(new_nodes_list, as.character)

    #}else
    if( !all( is.null(unlist(new_nodes_list) ) ) ){

      new_nodes_list <-  data.table::as.data.table( do.call( rbind, unlist(new_nodes_list, recursive = FALSE) ) )

      new_nodes_list[] <- lapply(new_nodes_list, as.character)

    }


  }

  return(new_nodes_list)
}

